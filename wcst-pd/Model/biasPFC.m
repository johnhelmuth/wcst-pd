%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This file bias the prefrontal cortex in two different ways:
% In the cortical schemas and in the basal ganglia unit
% The script is run each timeStep 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if counter.trial_num > 1
    
if counter.trial_num_time == 0
    
 averaging_int = counter.tt_trial_num(counter.trial_num-1):counter.tt_trial_num(counter.trial_num);
 pfc.actPFC(counter.trial_num,:) = nanmean(pfc.o_PFC(:,averaging_int), 2);
 pfc.pfcNoise = unifrnd(-ctx_noise,+ctx_noise,3,1);
   
 m_wneg = 1 - 2*reward.w_neg;   % previously w_rv

 % a w_neg lower than 1 could indicate either the negative reward
 % sensitivity, or it could be potentially conceptualised as 
 % a superordinate set of attentional schemas that ...
 
 if counter.trial_num < 1
     past_reward = [0 0 0];
     past_correct = 0;
 else  
     past_reward = reward.reward_value(counter.trial_num - 1,:);
     past_correct = sign(counter.correct_counter_vector(counter.trial_num) - 0.1);
 end
 
 %same as: match_sgn = normrnd(2*reward.w_rv - 1, reward.w_std,1,3)
if stimuli(counter.trial_num).colour == cardsTable(sma.indexSMA).colour
    match_sgn(1) = +1; 
else
    match_sgn(1) = -m_wneg - reward.mem_feat*(past_reward(1))*past_correct;
end

if stimuli(counter.trial_num).itemnum == cardsTable(sma.indexSMA).itemnum  
    match_sgn(2) = +1; 
else
    match_sgn(2) = -m_wneg - reward.mem_feat*(past_reward(2))*past_correct;
end

if stimuli(counter.trial_num).shape == cardsTable(sma.indexSMA).shape
    match_sgn(3) = +1; 
else
    match_sgn(3) = -m_wneg - reward.mem_feat*(past_reward(3))*past_correct;
end

% Note:
% in the way the function is designed reward.mem_feat incorporates both
% the memory for the reward (feedback) (how much the subject remember that
% the previous reward was correct or not and it weights it against the new
% one) and 

% Compared to w_neg (ex w_rv o w_rs) this parameter DOES NOT increase
% PE, but only IE and SL. This is important because probably IE are
% generated by a mix of variation in this parameter 'm' 


% Turns -into -1 and leaves +1 into +1
correct_sgn = sign(counter.correct_counter_vector(counter.trial_num) - 0.1); 

% Calculates c_i * r_i
reward.reward_value(counter.trial_num,:) = correct_sgn*match_sgn;

%reward.reward_value(counter.trial_num,:) = satlins(reward.reward_value(counter.trial_num,:));

reward.TDV(counter.trial_num,:) = reward.reward_value(counter.trial_num,:) - pfc.actPFC(counter.trial_num,:); 
reward.TDV(counter.trial_num,:) = reward.TDV(counter.trial_num,:);

% History-dependent learning
satfnc.beta_str_pfc = satlin(satfnc.beta_str_pfc - epsilon.eps_str.*reward.TDV(counter.trial_num,:));

% Apply noise to learning (discrete) in STR_PFC
satfnc.beta_str_pfc = satlin(satfnc.beta_str_pfc.*(1 + pfc.pfcNoise'));

% Register value (for output display)
satfnc.beta_str_pfc_hist(:,counter.trial_num) = satfnc.beta_str_pfc';

end
end